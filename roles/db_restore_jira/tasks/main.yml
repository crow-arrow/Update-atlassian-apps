---
- name: Detect dump file format
  ansible.builtin.shell: >
    file "{{ upload_dir }}/{{ now }}_{{ instance }}.dump"
  register: dump_format
  changed_when: false
  tags: [restore]

- name: Set use_pg_restore flag
  ansible.builtin.set_fact:
    use_pg_restore: "{{ 'PostgreSQL custom' in dump_format.stdout }}"
  tags: [restore]

- name: Set clean_sql path based on {{ app }}
  ansible.builtin.set_fact:
    clean_sql: "/usr/local/{{ app }}/clean_table.sql"
  tags: [restore]

- name: Clean PostgreSQL DB using clean_table.sql
  ansible.builtin.shell: >
    psql
    --host="{{ db_host }}"
    --port="{{ db_port | default(5432) }}"
    --username="{{ db_user }}"
    --dbname="{{ db_name }}"
    --file="{{ clean_sql }}"
  environment:
    PGPASSWORD: "{{ (app == 'jira') | ternary(jira_db_password, confluence_db_password) }}"
  become: true
  become_user: "{{ ENV_USER }}"
  register: clean_result
  changed_when: "'ERROR' not in clean_result.stderr"
  failed_when: clean_result.rc != 0
  tags: [restore]

# --- For plain SQL ---
- name: Restore PostgreSQL DB {{ app }} using psql (plain SQL)
  ansible.builtin.shell: >
    psql
    --host="{{ db_host }}"
    --port="{{ db_port | default(5432) }}"
    --username="{{ db_user }}"
    --dbname="{{ db_name }}"
    --file="{{ upload_dir }}/{{ now }}_{{ instance }}.dump"
    --echo-errors
    --echo-all
    --set ON_ERROR_STOP=on
    --set AUTOCOMMIT=off
    -v "ON_ERROR_STOP=1"
    > /tmp/psql_restore.log 2>&1
  environment:
    PGPASSWORD: "{{ (app == 'jira') | ternary(jira_db_password, confluence_db_password) }}"
  become: true
  become_user: "{{ ENV_USER }}"
  when: not use_pg_restore
  register: restore_result
  changed_when: false
  failed_when: restore_result.rc != 0
  tags: [restore]

- name: Analyze psql log for real execution errors
  ansible.builtin.shell: |
    grep -E '^(psql:|ERROR:|FATAL:|PANIC:|ROLLBACK)' /tmp/psql_restore.log || true
  register: log_scan_result
  changed_when: false
  failed_when: log_scan_result.stdout is defined and log_scan_result.stdout | trim != ""
  when: not use_pg_restore
  tags: [restore]

# --- For custom dump ---
- name: Restore PostgreSQL DB {{ app }} using pg_restore (custom format)
  ansible.builtin.shell: >
    pg_restore
    --host="{{ db_host }}"
    --port="{{ db_port | default(5432) }}"
    --username="{{ db_user }}"
    --dbname="{{ db_name }}"
    --clean 
    --if-exists
    "{{ upload_dir }}/{{ now }}_{{ instance }}.dump"
    --verbose
    --exit-on-error
    --no-owner
    --no-privileges
    --disable-triggers
    --jobs=4
    --use-set-session-authorization
    > /tmp/pg_restore.log 2>&1
  environment:
    PGPASSWORD: "{{ (app == 'jira') | ternary(jira_db_password, confluence_db_password) }}"
  become: true
  become_user: "{{ ENV_USER }}"
  when: use_pg_restore
  register: restore_result
  changed_when: false
  failed_when: restore_result.rc != 0
  tags: [restore]

- name: Analyze pg_restore log for real execution errors
  ansible.builtin.shell: |
    grep -E '^(ERROR:|FATAL:|PANIC:|ROLLBACK)' /tmp/pg_restore.log || true
  register: log_scan_result_pg
  changed_when: false
  failed_when: log_scan_result_pg.stdout is defined and log_scan_result_pg.stdout | trim != ""
  when: use_pg_restore
  tags: [restore]

- name: Remove uploaded dump file
  file:
    path: "{{ upload_dir }}/{{ now }}_{{ instance }}.dump"
    state: absent
  ignore_errors: true
  tags: [restore]
